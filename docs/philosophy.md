# Heejuna Engineering Framework - Core Philosophy

> "좋은 도구는 사용자를 더 나은 장인으로 만든다. AI는 도구다."

---

## 5대 핵심 원칙

### 1. Human Architect, AI Implementer

**출처**: Addy Osmani - "Agentic Engineering"

#### 원칙

인간은 **왜(Why)**와 **무엇(What)**을 결정하고, AI는 **어떻게(How)**를 실행한다. 이 경계는 절대로 뒤집어서는 안 된다.

#### 역할 분리

| 영역 | 인간의 역할 | AI의 역할 |
|------|-------------|-----------|
| 아키텍처 | 시스템 구조 설계, 기술 선택 | 설계를 코드로 변환 |
| 요구사항 | 비즈니스 요구 분석, 우선순위 결정 | 요구사항을 구현 태스크로 분해 |
| 품질 판단 | 코드 리뷰, UX 판단, 트레이드오프 결정 | 패턴 적용, 린트 규칙 준수 |
| 도메인 지식 | 비즈니스 규칙 정의, 엣지 케이스 식별 | 규칙을 코드로 인코딩 |

#### 핵심 인사이트

> "AI를 주니어 개발자가 아닌, 매우 빠른 타이피스트로 생각하라."
> -- Addy Osmani

AI는 놀라울 정도로 빠르게 코드를 생성하지만, **아키텍처 결정을 내릴 수 있는 판단력은 없다**. AI가 제안하는 구조를 무비판적으로 수용하면 **아키텍처 드리프트(Architecture Drift)**가 발생한다.

아키텍처 드리프트란, 작은 결정들이 누적되어 원래 의도한 시스템 구조에서 점진적으로 이탈하는 현상이다. AI가 "동작하는 코드"를 빠르게 생성할수록 이 위험은 커진다. 각각의 코드 조각은 동작하지만, 전체적으로는 일관성 없는 스파게티가 된다.

#### 방어 전략

1. **CLAUDE.md에 아키텍처 의사결정 기록**: AI가 매 세션마다 동일한 맥락에서 작업하도록 보장
2. **Skills로 구현 패턴 고정**: AI가 "창의적으로" 새로운 패턴을 만들지 않도록 제약
3. **Rules로 금지 사항 명시**: "절대 하지 말 것" 목록을 명확히 하여 드리프트 차단
4. **주기적 아키텍처 리뷰**: 인간이 전체 구조를 항상 파악하고 있어야 함

#### Agentic Engineering 맥락에서

Addy Osmani가 강조하는 Agentic Engineering의 핵심은 **AI를 자율 에이전트로 활용하되, 인간이 방향을 잡는 것**이다. 에이전트에게 "무엇을 만들어라"라고 지시하면 안 된다. "이 아키텍처 안에서, 이 패턴을 따라, 이것을 구현하라"고 구체적으로 제약해야 한다. 자율성의 범위를 인간이 설정하는 것이 핵심이다.

---

### 2. Verify Always, Trust Never

**출처**: Superpowers (obra) + METR 연구 결과

#### 원칙

AI가 생성한 모든 출력은 **유죄 추정(Guilty Until Proven Innocent)** 원칙에 따른다. 작동한다는 AI의 주장은 증거가 아니다.

#### 근거: METR 연구 결과

METR(Model Evaluation and Threat Research)의 실험 결과는 충격적이다:

> **검증 없이 AI 출력을 그대로 사용한 개발자는 오히려 19% 느려졌다.**

이는 AI가 잘못된 코드를 생성하기 때문만이 아니다. 잘못된 코드를 수정하는 데 드는 비용이, 처음부터 직접 작성하는 비용보다 크기 때문이다. "거의 맞지만 미묘하게 틀린" 코드는 디버깅 시간을 기하급수적으로 증가시킨다.

#### 검증의 3계층

```
Layer 1: 자동 검증 (Quality Gate Hook)
  - lint (ESLint, Ruff)
  - typecheck (TypeScript, Pyright)
  - 단위 테스트 (vitest, pytest)
  - 커밋 전 자동 실행, 통과 못하면 커밋 차단

Layer 2: 반자동 검증 (테스트 실행)
  - 통합 테스트
  - E2E 테스트 (Playwright)
  - 개발자가 트리거하지만 자동 판정

Layer 3: 수동 검증 (인간 판단)
  - 코드 리뷰 (아키텍처 적합성, 도메인 정확성)
  - UX 검토 (사용자 관점에서 적절한가)
  - 성능 검토 (N+1 쿼리, 불필요한 렌더링 등)
```

#### 증거 기반 개발 (Evidence-Based Development)

"작동합니다"라고 말하지 마라. **증명하라.**

| 주장 | 증거 |
|------|------|
| "버그를 수정했습니다" | 실패하는 테스트 -> 수정 -> 테스트 통과 |
| "성능이 개선됐습니다" | before/after 벤치마크 수치 |
| "타입이 안전합니다" | typecheck 통과 로그 |
| "보안 문제가 없습니다" | SQL injection 테스트, 인증 우회 테스트 |

#### 실천 방법

1. **Quality Gate Hook**: 모든 커밋에 자동 검증 실행 (lint + typecheck 최소)
2. **TDD 적극 활용**: 테스트를 먼저 작성하면 AI 출력의 정확성을 즉시 판별 가능
3. **점진적 신뢰 구축**: AI가 올바른 출력을 반복적으로 생성하는 패턴을 확인한 후에만 검증 강도 조절
4. **실패 기록**: AI가 잘못 생성한 패턴을 MEMORY.md에 기록하여 재발 방지

---

### 3. Right-Sized Process

**출처**: Martin Fowler - "적절한 프로세스는 작업의 크기와 위험도에 비례해야 한다"

#### 원칙

모든 작업에 동일한 무거운 프로세스를 강제하면 생산성이 죽는다. 반대로, 위험한 작업에 가벼운 프로세스를 적용하면 품질이 죽는다. **작업의 크기와 위험도에 정확히 비례하는 프로세스를 적용하라.**

#### 작업 크기 분류

```
Small (S)   : 5분 이내. 타이포 수정, 상수값 변경, 1줄 수정
Medium (M)  : 30분~2시간. 버그 수정, 간단한 기능 추가, 컴포넌트 하나 작성
Large (L)   : 반나절~하루. 새 기능 모듈, 리팩토링, 여러 파일 변경
X-Large (XL): 며칠 이상. 아키텍처 변경, 대규모 마이그레이션, 시스템 재설계
```

#### 크기별 프로세스 매핑

| 크기 | 계획 | 리뷰 | 구현 | 검증 |
|------|------|------|------|------|
| **S** | 없음 | 없음 | 바로 수행 | Quality Gate 자동 |
| **M** | 간단한 분석 | 없음 | todo 추적 | Quality Gate + 수동 테스트 |
| **L** | Prometheus 계획 | Momus 리뷰 | Sisyphus 구현 | Quality Gate + 자동/수동 테스트 |
| **XL** | 풀 계획 문서 | 다각도 리뷰 | 단계별 구현 | 풀 스택 검증 |

#### 과잉 프로세스의 해악

타이포 수정에 Prometheus 계획을 돌리는 것은 연필 하나 옮기려고 이삿짐센터를 부르는 것과 같다. 시간 낭비일 뿐 아니라, 진짜 중요한 작업에서 프로세스의 가치를 희석시킨다. 팀원들이 "또 프로세스?"라는 피로감을 느끼기 시작하면, 정작 XL 작업에서도 프로세스를 대충 넘기게 된다.

#### 과소 프로세스의 해악

아키텍처 변경을 "그냥 해보고 되면 됐지" 식으로 접근하면, 나중에 되돌리기 불가능한 기술 부채가 쌓인다. 특히 AI를 사용할 때, "AI가 빠르게 만들어주니까 일단 해보자"는 유혹이 강하다. 하지만 빠르게 만든 것은 빠르게 무너진다.

#### 크기 판단 기준

1. **변경 파일 수**: 1개(S), 2~5개(M), 5~15개(L), 15개+(XL)
2. **영향 범위**: 로컬(S/M), 모듈(L), 시스템(XL)
3. **되돌리기 난이도**: 즉시(S), 쉬움(M), 어려움(L), 불가(XL)
4. **도메인 복잡도**: 없음(S), 낮음(M), 중간(L), 높음(XL)

---

### 4. Domain Knowledge as Code

**출처**: Eric Evans - "Domain-Driven Design"

#### 원칙

개발자의 머릿속에만 존재하는 암묵적 도메인 지식은, AI에게는 존재하지 않는 지식이다. **AI가 도메인 전문가처럼 행동하게 만드는 유일한 방법은, 도메인 지식을 코드(텍스트)로 명시하는 것이다.**

#### DDD 개념과의 매핑

| DDD 개념 | Heejuna Engineering 대응물 | 역할 |
|----------|---------------------------|------|
| **Ubiquitous Language** | CLAUDE.md | 프로젝트의 공용 언어 정의. 모든 용어, 약어, 관계를 명시 |
| **Bounded Context** | 프로젝트별 rules/ | 각 컨텍스트(프로젝트)마다 다른 규칙이 적용됨을 명시 |
| **Aggregate** | skills/ | 하나의 완결된 작업 단위. 내부 일관성 보장 |
| **Domain Event** | MEMORY.md | 프로젝트에서 발생한 중요한 사건과 학습을 기록 |
| **Anti-Corruption Layer** | rules/ (금지 규칙) | 외부 패턴이 내부 도메인을 오염시키지 못하도록 방어 |

#### 암묵적 지식 -> 명시적 규칙 변환 예시

**Before (암묵적 지식 - 개발자 머릿속에만 존재)**:
> "아, 계약 테이블은 함부로 건드리면 안 돼. 정산이랑 엮여 있어서..."

**After (명시적 규칙 - CLAUDE.md에 코드화)**:
```markdown
### 마이그레이션 우선순위
계약(contract)과 정산(settlement)을 제외한 모든 영역에서 먼저 진행한다.
계약/정산은 비즈니스 임팩트가 크므로 충분한 안정화 후 마이그레이션한다.
```

**Before (암묵적 지식)**:
> "SQL은 f-string으로 쓰면 안 돼, 보안 이슈 있어"

**After (명시적 규칙 - rules/ 또는 CLAUDE.md)**:
```markdown
### SQL 안전성 규칙 (MANDATORY)
- 절대 금지: f"col = '{val}'"
- 필수 패턴: %s 바인딩
```

#### 도메인 지식 계층 구조

```
CLAUDE.md (프로젝트 루트)
  -- 프로젝트 전체에 적용되는 핵심 도메인 지식
  -- 아키텍처 결정, 기술 스택, 배포 방식

rules/ (조건부 활성화)
  -- 특정 상황에서만 필요한 세부 규칙
  -- 파일 패턴 매칭으로 자동 활성화

skills/ (명시적 호출)
  -- 특정 작업 유형의 완전한 수행 절차
  -- /slash-command로 호출

MEMORY.md (학습 기록)
  -- 프로젝트에서 축적된 경험적 지식
  -- 트러블슈팅, 주의사항, 패턴
```

#### 왜 이것이 중요한가

AI 에이전트는 매 세션마다 기억을 잃는다. CLAUDE.md 없이 AI를 사용하는 것은, 매일 아침 새로운 인턴에게 프로젝트를 설명하는 것과 같다. 도메인 지식을 코드로 작성해두면, AI는 매 세션마다 **즉시** 도메인 전문가 수준의 컨텍스트를 획득한다.

---

### 5. Context is King

**출처**: Anthropic Best Practices - "The context window is your most precious resource"

#### 원칙

컨텍스트 윈도우는 AI의 "작업 메모리"다. 이 제한된 공간에 무엇을 넣느냐가 AI 출력의 품질을 결정한다. **불필요한 정보로 오염시키지 말고, 필요한 정보를 계층적으로 제공하라.**

#### 컨텍스트 윈도우의 본질

AI의 컨텍스트 윈도우를 **책상 위 공간**으로 생각하라:

- 책상이 넓다고 모든 서류를 올려놓으면 안 된다
- 지금 필요한 서류만 펼쳐놓고, 나머지는 서랍에 정리해야 한다
- 서랍에서 꺼내기 쉽도록 라벨을 붙여놓아야 한다

#### 계층적 컨텍스트 구조

```
항상 로드 (Level 0)
  CLAUDE.md
  -- 모든 상호작용에서 기본으로 제공
  -- 프로젝트 핵심 정보만 간결하게

관련 시 자동 로드 (Level 1)
  rules/ (파일 패턴 매칭)
  -- .py 편집 시 -> python 관련 rules 자동 활성화
  -- .vue 편집 시 -> Vue/Nuxt 관련 rules 자동 활성화

명시적 호출 시 로드 (Level 2)
  skills/ (/slash-command)
  -- 특정 작업 시작 시에만 로드
  -- 작업 완료 후 컨텍스트에서 해제

참조용 (Level 3)
  MEMORY.md, 외부 문서
  -- 필요할 때만 검색하여 참조
  -- 전체를 로드하지 않고 관련 부분만 추출
```

#### 컨텍스트 오염 방지 전략

1. **CLAUDE.md는 간결하게**: 핵심 정보만. 상세 내용은 하위 문서에서 참조
2. **Rules는 조건부로**: 항상 모든 규칙을 로드하지 않고, 관련 파일 작업 시에만 활성화
3. **Skills는 필요할 때만**: /slash-command로 명시적으로 호출
4. **Agent 위임으로 보호**: 큰 작업을 하위 에이전트에게 위임하면, 메인 에이전트의 컨텍스트가 보호됨

#### 에이전트 위임과 컨텍스트 보호

하위 에이전트에게 작업을 위임하면, 각 에이전트는 **독립된 컨텍스트 윈도우**를 가진다. 이는 곧:

- 메인 에이전트의 컨텍스트가 세부 구현 코드로 오염되지 않음
- 각 하위 에이전트는 자신의 작업에 필요한 컨텍스트만 보유
- 결과만 메인 에이전트에게 전달되므로 컨텍스트 효율 극대화

```
Main Agent (아키텍처 전체 파악)
  |
  +-- Agent A (프론트엔드 컴포넌트 구현)
  |     -- 프론트엔드 코드만 컨텍스트에 보유
  |
  +-- Agent B (백엔드 API 구현)
  |     -- 백엔드 코드만 컨텍스트에 보유
  |
  +-- Agent C (테스트 작성)
        -- 테스트 관련 코드만 컨텍스트에 보유
```

#### 정보 밀도 최적화

CLAUDE.md를 작성할 때는 **정보 밀도**를 최대화하라:

- **나쁜 예**: 장황한 설명, 중복 정보, 예시 없는 규칙
- **좋은 예**: 테이블 형식, 코드 예시, 명확한 DO/DON'T

```markdown
# 나쁜 예 (정보 밀도 낮음)
우리 프로젝트에서는 SQL을 작성할 때 f-string을 사용하면 안 됩니다.
왜냐하면 SQL injection 위험이 있기 때문입니다.
대신 파라미터 바인딩을 사용해야 합니다.

# 좋은 예 (정보 밀도 높음)
SQL: f-string 금지, %s 바인딩 필수. IN절은 = ANY(%s) 사용.
```

---

## 통합 프레임워크: DDD + AI Engineering

### DDD와의 심층 통합

Heejuna Engineering Framework는 DDD의 전략적 패턴을 AI 개발 환경에 재해석한다.

#### Bounded Context = Project Rules

각 프로젝트(또는 도메인)는 자체적인 규칙 경계를 가진다. 프론트엔드의 규칙과 백엔드의 규칙은 다르다. 같은 용어도 컨텍스트에 따라 다른 의미를 가질 수 있다.

```
wcloud-front/CLAUDE.md    -- 프론트엔드 Bounded Context
wportal-backend/CLAUDE.md -- 백엔드 Bounded Context
```

프론트엔드에서 "모듈"은 Nuxt 레이어를, 백엔드에서 "모듈"은 FastAPI 라우터를 의미한다. 이 구분을 각 컨텍스트의 CLAUDE.md에 명시함으로써 AI의 혼동을 방지한다.

#### Ubiquitous Language = CLAUDE.md 용어 정의

프로젝트 참여자(인간과 AI 모두)가 동일한 용어를 동일한 의미로 사용하도록 보장한다.

```markdown
## 용어 정의
- **유료DB (paid-db)**: 보험 가입자 DB 중 유료로 제공되는 데이터셋
- **배치DB (batch-db)**: 정기적으로 일괄 처리되는 데이터셋
- **정산 (settlement)**: 보험금 지급 관련 재무 처리 프로세스
```

#### Aggregate = Skills

Skills는 DDD의 Aggregate와 유사한 역할을 한다. 하나의 완결된 작업 단위를 정의하며, 내부 일관성을 보장한다.

```
/v2-api     -- v2 API 모듈이라는 하나의 완결된 생성 단위
/v2-feature -- 풀스택 기능이라는 하나의 완결된 생성 단위
```

Skill 내부의 모든 단계는 Aggregate 내부의 불변식(invariant)처럼, 반드시 함께 수행되어야 한다. v2 API를 만들 때 router만 만들고 service를 빠뜨리면 안 되는 것처럼.

---

## TDD 전략: 언제, 어떻게 적용하는가

**출처**: Anthropic "Superpowers" - TDD 워크플로우 권장

### AI 시대의 TDD가 다른 이유

전통적 TDD에서는 "테스트 작성 -> 구현 -> 리팩토링" 사이클을 인간이 수행했다. AI 시대에는 이 사이클의 역할 분배가 달라진다:

```
인간: 테스트 케이스 설계 (무엇을 검증할 것인가)
AI:   테스트 코드 작성 (설계를 코드로 변환)
AI:   구현 코드 작성 (테스트를 통과하도록)
인간: 테스트 결과 리뷰 (의도대로 동작하는가)
```

### TDD 적용 기준

| 작업 유형 | TDD 적용 | 이유 |
|-----------|----------|------|
| 새 비즈니스 로직 | **필수** | 도메인 규칙의 정확성 보장 |
| 버그 수정 | **강력 권장** | 회귀 방지 (실패 테스트 먼저 작성) |
| API 엔드포인트 | **권장** | 계약(contract) 검증 |
| UI 컴포넌트 | 선택적 | 시각적 검증이 더 효과적인 경우 |
| 리팩토링 | **필수** | 기존 동작 보존 확인 |
| 유틸리티 함수 | **필수** | 입출력이 명확하므로 TDD 효과 극대화 |

### Superpowers TDD 워크플로우

Anthropic의 "Superpowers" 연구에서 권장하는 AI 활용 TDD 패턴:

1. **인간이 테스트 시나리오를 자연어로 기술**
   ```
   "사용자가 만료된 토큰으로 API를 호출하면 401을 반환하고,
    refresh token이 유효하면 자동으로 토큰을 갱신해야 한다"
   ```

2. **AI가 테스트 코드로 변환**
   ```python
   def test_expired_token_returns_401():
       ...
   def test_auto_refresh_with_valid_refresh_token():
       ...
   ```

3. **AI가 테스트를 통과하는 구현 작성**

4. **인간이 테스트 커버리지와 엣지 케이스 검토**

이 워크플로우에서 인간은 "무엇을 테스트할 것인가"에 집중하고, AI는 "어떻게 테스트하고 구현할 것인가"를 담당한다. 이것이 **Human Architect, AI Implementer** 원칙의 TDD 적용이다.

---

## Agentic Engineering 인사이트

**출처**: Addy Osmani - 에이전트 기반 소프트웨어 엔지니어링

### 에이전트의 본질적 한계와 활용법

AI 에이전트는 강력하지만, 근본적인 한계를 이해해야 올바르게 활용할 수 있다.

#### 에이전트가 잘하는 것

- **패턴 적용**: 한 번 정의된 패턴을 일관되게 반복 적용
- **보일러플레이트 생성**: 정형화된 코드의 빠른 생성
- **리팩토링 실행**: 인간이 정한 방향으로의 코드 변환
- **병렬 작업**: 독립적인 여러 작업의 동시 수행
- **검색과 분석**: 대규모 코드베이스에서의 패턴 탐색

#### 에이전트가 못하는 것

- **아키텍처 판단**: 시스템 수준의 트레이드오프 결정
- **비즈니스 가치 평가**: 무엇이 중요하고 무엇이 아닌지 판단
- **미학적 판단**: UX의 "느낌", 코드의 "우아함" 평가
- **정치적 판단**: 팀 역학, 이해관계자 관리
- **창의적 문제 해결**: 기존 패턴에 없는 새로운 접근법 도출

#### 에이전트 활용의 핵심 패턴

**1. 제약 기반 자율성 (Constrained Autonomy)**

에이전트에게 최대한의 자율성을 주되, 명확한 경계 안에서만.

```
CLAUDE.md: "모든 새 API는 v2 패턴을 따를 것"
Skills: "/v2-api - router/service/repository 3계층 분리"
Rules: "f-string SQL 절대 금지"
```

이 제약 안에서 에이전트는 자유롭게 구현할 수 있다. 제약이 명확할수록 에이전트의 자율성은 높아진다.

**2. 점진적 위임 (Progressive Delegation)**

처음에는 작은 작업만 위임하고, 신뢰가 쌓이면 더 큰 작업을 위임한다.

```
Level 1: 단일 파일 수정 (타이포 수정, 상수 변경)
Level 2: 단일 모듈 구현 (API 엔드포인트 하나)
Level 3: 기능 단위 구현 (프론트+백엔드)
Level 4: 시스템 단위 변경 (아키텍처 리팩토링)
```

**3. 검증 루프 내장 (Built-in Verification Loop)**

에이전트의 작업 결과를 자동으로 검증하는 메커니즘을 내장한다.

```
구현 -> lint -> typecheck -> test -> (통과) -> 커밋
                                   -> (실패) -> 재시도
```

이것이 Quality Gate Hook의 본질이다. 에이전트가 "완료"라고 선언하기 전에, 객관적인 검증을 통과해야 한다.

---

## 원칙 간의 상호 관계

5대 원칙은 독립적이 아니라 유기적으로 연결된다:

```
Context is King (5)
  -- 올바른 컨텍스트가 제공되어야

Domain Knowledge as Code (4)
  -- 도메인 지식이 코드로 존재해야

Human Architect, AI Implementer (1)
  -- 인간이 방향을 잡고 AI가 실행하며

Verify Always, Trust Never (2)
  -- 결과를 항상 검증하되

Right-Sized Process (3)
  -- 작업 크기에 맞는 적절한 프로세스로
```

이 5가지 원칙이 모두 작동할 때, AI는 단순한 코드 생성기를 넘어 **신뢰할 수 있는 엔지니어링 파트너**가 된다.
