# Heejuna Engineering Framework - Methodology

> "올바른 도구를 올바른 시기에 올바른 크기로 적용하라."

---

## 작업 크기별 워크플로우

모든 작업은 수행 전에 **크기를 판단**하고, 크기에 맞는 워크플로우를 적용한다. 이것이 **Right-Sized Process** 원칙의 실천이다.

---

### Small (S) - 즉시 수행

**정의**: 5분 이내 완료, 1~2줄 변경, 영향 범위가 해당 파일로 한정

**예시**:
- 타이포 수정
- 상수값 변경
- import 문 추가/제거
- 주석 수정
- 환경 변수 값 변경

#### 워크플로우

```
요청 수신 → 바로 수행 → Quality Gate 자동 검증 → 완료
```

#### 상세

| 항목 | 내용 |
|------|------|
| **프로세스** | 없음. 계획이나 리뷰 불필요 |
| **도구** | Edit/Write 직접 사용 |
| **검증** | Quality Gate Hook 자동 실행 (lint, typecheck) |
| **커밋** | 단일 커밋. 메시지는 간결하게 |
| **예상 소요** | 1~5분 |

#### 판단 기준

- 변경 파일: 1개
- 변경 라인: 1~5줄
- 되돌리기: 즉시 가능
- 테스트 필요: 불필요 (기존 테스트로 충분)

---

### Medium (M) - 분석 후 구현

**정의**: 30분~2시간, 단일 모듈 범위, 논리적 사고 필요

**예시**:
- 버그 수정 (원인 분석 필요)
- 간단한 기능 추가 (API 엔드포인트 하나)
- 컴포넌트 하나 작성/수정
- 쿼리 최적화
- 기존 함수에 파라미터 추가

#### 워크플로우

```
요청 수신 → 분석 (코드 읽기, 원인 파악) → 구현 계획 (todo) → 구현 → 검증 → 완료
```

#### 상세

| 항목 | 내용 |
|------|------|
| **프로세스** | 분석 -> 구현 -> 검증 |
| **도구** | `sisyphus` (todo tracking), `systematic-debugging` (버그인 경우) |
| **검증** | Quality Gate + 수동 테스트 확인 |
| **커밋** | 1~3개 커밋. 논리적 단위로 분리 |
| **예상 소요** | 30분~2시간 |

#### 버그 수정 시 추가 프로세스

버그 수정은 Medium 작업의 가장 흔한 유형이다. **Systematic Debugging** 방법론을 적용한다:

```
1. 증상 확인: 정확히 어떤 동작이 잘못되었는가?
2. 재현: 어떤 조건에서 발생하는가?
3. 가설 수립: 가능한 원인 3가지 이상 나열
4. 가설 검증: 각 가설을 하나씩 검증 (로그, 디버거, 테스트)
5. 근본 원인 확정: 증거 기반으로 확정
6. 수정: 근본 원인 해결 (증상만 가리지 않기)
7. 회귀 테스트: 같은 버그가 재발하지 않도록 테스트 추가
```

**핵심**: AI에게 "이 버그를 고쳐줘"라고 하면, AI는 증상을 가리는 패치를 만들 수 있다. **반드시 근본 원인을 먼저 파악**하고 수정을 지시해야 한다. 이것이 **Human Architect, AI Implementer** 원칙의 디버깅 적용이다.

#### 판단 기준

- 변경 파일: 2~5개
- 변경 라인: 10~100줄
- 되돌리기: 쉬움
- 테스트 필요: 권장 (특히 버그 수정 시 필수)

---

### Large (L) - 계획 -> 리뷰 -> 구현

**정의**: 반나절~하루, 여러 모듈에 걸친 변경, 설계 결정 포함

**예시**:
- 새 기능 모듈 추가 (프론트엔드 페이지 + 백엔드 API)
- 기존 모듈 리팩토링
- 디자인 시스템 컴포넌트 추가
- 데이터베이스 스키마 변경 + 관련 코드 수정
- 인증/권한 로직 변경

#### 워크플로우

```
요청 수신
  → 계획 (Prometheus)
    → 리뷰 (Momus)
      → 구현 (Sisyphus + Ultrawork)
        → 검증 (Quality Gate + 자동 테스트 + 코드 리뷰)
          → 완료
```

#### 상세

| 항목 | 내용 |
|------|------|
| **프로세스** | 계획(prometheus) -> 리뷰(momus) -> 구현(sisyphus) -> 검증 |
| **도구** | `prometheus` (계획), `momus` (리뷰), `sisyphus` (구현), `ultrawork` (병렬화), `git-master` (커밋 관리) |
| **검증** | Quality Gate + 자동 테스트(vitest/pytest) + 인간 코드 리뷰 |
| **커밋** | 기능 단위 커밋. 커밋 히스토리가 변경의 논리를 설명하도록 |
| **예상 소요** | 4~8시간 |

#### 계획 단계 (Prometheus)

```
1. 요구사항 명확화: 사용자 인터뷰로 누락된 요구사항 도출
2. 영향 분석: 변경이 미치는 범위 파악
3. 작업 분해: 독립적으로 수행 가능한 단위로 분해
4. 의존성 파악: 작업 간 순서 의존성 식별
5. 위험 식별: 실패 가능성이 높은 부분 선제 파악
6. 계획 문서 생성: 위 내용을 구조화된 문서로 정리
```

#### 리뷰 단계 (Momus)

```
1. 누락된 요구사항: 계획이 원래 요구사항을 모두 충족하는가?
2. 기술적 타당성: 제안된 구현 방식이 현실적인가?
3. 아키텍처 적합성: 기존 아키텍처와 일관성이 있는가?
4. 엣지 케이스: 놓친 예외 상황은 없는가?
5. 테스트 전략: 검증 계획이 충분한가?
```

#### 구현 단계 (Sisyphus + Ultrawork)

독립적인 작업은 **병렬로** 수행한다:

```
[Task 1: DB 마이그레이션]  ──┐
[Task 2: 백엔드 API]       ──┼── 병렬 수행 (Ultrawork)
[Task 3: 프론트엔드 컴포넌트] ──┘
                              ↓
[Task 4: 통합 연결]         ── 순차 수행 (의존성 존재)
                              ↓
[Task 5: 테스트 작성]       ── 순차 수행
```

#### 판단 기준

- 변경 파일: 5~15개
- 변경 라인: 100~500줄
- 되돌리기: 어려움 (여러 파일에 걸친 변경)
- 테스트 필요: 필수

---

### X-Large (XL) - 풀 프로세스

**정의**: 며칠 이상, 시스템 수준 변경, 되돌리기 어렵거나 불가능

**예시**:
- 모노레포 마이그레이션
- 프레임워크 교체 (Quasar -> Woori DS)
- 데이터베이스 마이그레이션 (스키마 대규모 변경)
- API 버전 전체 마이그레이션 (v1 -> v2)
- 인증 시스템 교체
- 배포 파이프라인 전면 개편

#### 워크플로우

```
요청 수신
  → 요구사항 심층 분석
    → 아키텍처 설계 (Prometheus + 인간 협업)
      → 다각도 리뷰 (Momus + Metis)
        → 단계별 마이그레이션 계획
          → 1단계 구현 + 검증
            → 2단계 구현 + 검증
              → ...
                → N단계 구현 + 검증
                  → 통합 테스트
                    → 롤백 계획 확인
                      → 배포
```

#### 상세

| 항목 | 내용 |
|------|------|
| **프로세스** | 요구사항 분석 -> 계획 -> 리뷰 -> 단계별 구현 -> 통합 테스트 |
| **도구** | 풀 스택. 모든 에이전트 활용 (prometheus, momus, metis, sisyphus, ultrawork, git-master 등) |
| **검증** | Quality Gate + 자동 테스트 + E2E 테스트 + 성능 테스트 + 인간 리뷰 |
| **커밋** | 단계별 독립 커밋. 각 단계가 독립적으로 배포 가능하도록 |
| **예상 소요** | 수일~수주 |

#### XL 작업의 핵심: 단계적 마이그레이션

XL 작업을 한 번에 수행하려 하면 실패한다. **각 단계가 독립적으로 배포 가능한** 점진적 마이그레이션이 핵심이다.

```
Phase 1: 새 구조 병행 도입 (기존 코드 변경 없음)
  -- 새 패턴을 도입하되, 기존 코드는 그대로 유지
  -- 새 코드만 새 패턴 적용
  -- 위험도: 낮음 (기존 시스템 무영향)

Phase 2: 점진적 마이그레이션 (하나씩 이동)
  -- 위험도가 낮은 모듈부터 새 패턴으로 이동
  -- 각 이동 후 충분한 안정화 기간
  -- 문제 발생 시 개별 롤백 가능

Phase 3: 레거시 제거 (안정화 확인 후)
  -- 모든 모듈 마이그레이션 완료 후
  -- 레거시 코드/의존성 제거
  -- 최종 정리 및 문서 업데이트
```

#### Metis 사전 분석

XL 작업에서는 **Metis**를 활용한 사전 위험 분석이 필수다:

```
Metis 분석 항목:
1. 숨겨진 요구사항: 명시되지 않았지만 암묵적으로 필요한 것
2. 기술적 위험: 호환성, 성능, 데이터 무결성 위험
3. 조직적 위험: 팀 역량, 일정 압박, 이해관계자 갈등
4. 롤백 전략: 각 단계별 롤백 방법과 비용
5. 성공 기준: 마이그레이션 완료를 어떻게 판단할 것인가
```

#### 판단 기준

- 변경 파일: 15개 이상
- 변경 라인: 500줄 이상
- 되돌리기: 불가능하거나 매우 어려움
- 테스트 필요: 풀 스택 검증 필수

---

## Skill 선택 흐름도

작업이 주어졌을 때, 어떤 Skill 조합을 사용할 것인지 결정하는 의사결정 트리다.

### Step 1: 작업 크기 판단

```
작업이 들어왔다
  |
  +-- 파일 1개, 5줄 이하 변경? ─── YES ──→ Small (S)
  |
  +-- 파일 2~5개, 100줄 이하? ─── YES ──→ Medium (M)
  |
  +-- 파일 5~15개, 설계 필요? ─── YES ──→ Large (L)
  |
  +-- 시스템 수준 변경, 며칠 이상? ── YES ──→ X-Large (XL)
```

### Step 2: 실행 Skill 선택

```
작업 크기 확정
  |
  +-- Small ──→ 실행 Skill 없음 (직접 수행)
  |
  +-- Medium ──→ sisyphus (todo tracking + 순차 실행)
  |
  +-- Large ──→ 계획이 필요한가?
  |              |
  |              +-- YES ──→ prometheus (계획) → sisyphus (실행)
  |              +-- NO  ──→ sisyphus (실행)
  |
  +-- X-Large ──→ prometheus (계획) → momus (리뷰) → sisyphus (실행)
```

### Step 3: 보강 Skill 추가

```
실행 Skill 결정됨
  |
  +-- 독립적 병렬 작업이 3개 이상? ──→ + ultrawork
  |
  +-- 변경 파일이 3개 이상? ──→ + git-master
  |
  +-- UI/프론트엔드 작업? ──→ + frontend-ui-ux
  |
  +-- 버그 수정? ──→ + systematic-debugging
```

### Step 4: 보증 Skill 판단

```
Skill 조합 결정됨
  |
  +-- 사용자가 "반드시 완료해라" 강조? ──→ + ralph-loop
  |
  +-- 작업이 중단되면 안 되는 상황? ──→ + ralph-loop
  |
  +-- 여러 세션에 걸쳐 수행? ──→ + ralph-loop
  |
  +-- 일반적인 작업? ──→ 보증 Skill 불필요
```

### Step 5: 방법론 Skill 적용

```
모든 Skill 결정됨
  |
  +-- 새 비즈니스 로직? ──→ TDD 적용 (테스트 먼저)
  |
  +-- 버그 수정? ──→ Systematic Debugging (가설 → 검증)
  |
  +-- 리팩토링? ──→ TDD 적용 (기존 테스트 확인 → 리팩토링 → 테스트 통과)
  |
  +-- 단순 기능 추가? ──→ 구현 후 테스트 (Test-After 허용)
```

### 전체 흐름 요약

```
작업 수신
  → [Step 1] 크기 판단 (S / M / L / XL)
    → [Step 2] 실행 Skill (없음 / sisyphus / prometheus+sisyphus)
      → [Step 3] 보강 Skill (+ultrawork / +git-master / +frontend-ui-ux)
        → [Step 4] 보증 Skill (+ralph-loop 여부)
          → [Step 5] 방법론 Skill (TDD / Debugging)
            → 수행
```

---

## 예시 시나리오

### 시나리오 1: "로그인 버튼 텍스트 변경"

**분석**:
- 변경 파일: 1개
- 변경 라인: 1줄
- 영향 범위: 해당 컴포넌트만
- 되돌리기: 즉시

**판정: Small (S)**

**Skill 조합**: 없음 (직접 수행)

**워크플로우**:
```
1. 해당 컴포넌트 파일 찾기
2. 텍스트 변경 (Edit)
3. Quality Gate 자동 검증 (lint 통과 확인)
4. 완료
```

**소요 시간**: 1~2분

---

### 시나리오 2: "API 응답이 500 에러"

**분석**:
- 원인 불명: 디버깅 필요
- 변경 파일: 1~5개 (원인에 따라 다름)
- 영향 범위: 해당 API 모듈
- 되돌리기: 쉬움

**판정: Medium (M)**

**Skill 조합**: `sisyphus` + `systematic-debugging`

**워크플로우**:
```
1. [분석] 증상 확인
   - 어떤 엔드포인트에서 500이 발생하는가?
   - 항상 발생하는가, 특정 조건에서만 발생하는가?
   - 서버 로그에 어떤 에러가 기록되어 있는가?

2. [가설 수립] 가능한 원인 나열
   - 가설 A: DB 커넥션 풀 고갈
   - 가설 B: NULL 값 참조 에러
   - 가설 C: 잘못된 쿼리 파라미터 처리

3. [가설 검증] 하나씩 검증
   - 로그 확인 → 가설 B 유력 (NoneType has no attribute 'id')
   - 해당 코드 라인 확인 → 선택적 관계에서 None 체크 누락

4. [수정] 근본 원인 해결
   - None 체크 추가
   - 동일 패턴의 다른 코드도 확인하여 일괄 수정

5. [검증]
   - 해당 엔드포인트 호출 테스트
   - 회귀 테스트 추가 (None 케이스)
   - Quality Gate 통과 확인

6. [완료] 커밋
```

**소요 시간**: 30분~1시간

**핵심 포인트**: AI에게 "500 에러 고쳐줘"라고 하지 않는다. **Systematic Debugging**을 통해 근본 원인을 먼저 파악한 후, 수정을 지시한다. 증상 패치가 아닌 근본 해결을 보장하는 것이 **Verify Always** 원칙의 적용이다.

---

### 시나리오 3: "유저 프로필 페이지 추가"

**분석**:
- 새 기능: 프론트엔드 페이지 + 백엔드 API + DB 쿼리
- 변경 파일: 10~15개
- 영향 범위: 새 모듈 (기존 코드 영향 적음)
- 설계 결정 필요: 페이지 구조, API 설계, 데이터 모델

**판정: Large (L)**

**Skill 조합**: `prometheus` (계획) + `momus` (리뷰) + `sisyphus` (구현) + `ultrawork` (병렬 실행) + `git-master` (커밋 관리)

**워크플로우**:

```
[Phase 1: 계획 - Prometheus]

1. 요구사항 인터뷰
   - 프로필에 어떤 정보를 표시하는가?
   - 편집 가능한 필드는 무엇인가?
   - 권한 체계: 본인만 수정 가능? 관리자도 가능?
   - 모바일 대응 필요한가?

2. 작업 분해
   - Task 1: 백엔드 API (GET /v2/user/profile, PUT /v2/user/profile)
   - Task 2: 프론트엔드 페이지 (/user/profile)
   - Task 3: 프론트엔드 컴포넌트 (ProfileForm, ProfileAvatar)
   - Task 4: 메뉴 등록 + 권한 설정
   - Task 5: 테스트 작성

3. 의존성 분석
   - Task 1, 2, 3: 병렬 수행 가능
   - Task 4: Task 2 완료 후
   - Task 5: Task 1, 2, 3 완료 후
```

```
[Phase 2: 리뷰 - Momus]

1. API 설계 리뷰
   - RESTful 규칙 준수 여부
   - 응답 스키마가 v2 패턴과 일관적인가

2. 보안 리뷰
   - 본인 프로필만 수정할 수 있도록 권한 체크가 있는가
   - 민감 필드(비밀번호 등) 노출 방지

3. UX 리뷰
   - 필드 배치가 직관적인가
   - 에러 메시지가 사용자 친화적인가
```

```
[Phase 3: 구현 - Sisyphus + Ultrawork]

병렬 실행:
  [Agent A] 백엔드 API 구현
    - router: api/v2/user/router.py
    - service: api/v2/user/service.py
    - repository: api/v2/user/repository.py

  [Agent B] 프론트엔드 페이지
    - pages: web/app/pages/user/profile.vue
    - components: web/app/components/v2/user/ProfileForm.vue

  [Agent C] 프론트엔드 API 모듈
    - module: base/app/utils/api/v2/module/user.ts
    - composable 등록: base/app/composables/v2Api.ts

순차 실행:
  [Task 4] 메뉴/권한 등록
  [Task 5] 테스트 작성 (백엔드 pytest + 프론트엔드 vitest)
```

```
[Phase 4: 검증]

1. Quality Gate: lint + typecheck 통과
2. 자동 테스트: pytest + vitest 통과
3. 수동 테스트: 브라우저에서 프로필 조회/수정 확인
4. 코드 리뷰: 아키텍처 적합성, 도메인 규칙 준수 확인
```

**소요 시간**: 4~6시간

---

### 시나리오 4: "모노레포 마이그레이션"

**분석**:
- 시스템 수준 변경: 프로젝트 구조 전면 변경
- 변경 파일: 50개 이상
- 영향 범위: 전체 시스템
- 되돌리기: 매우 어려움
- 위험도: 매우 높음

**판정: X-Large (XL)**

**Skill 조합**: 풀 스택 (prometheus + metis + momus + sisyphus + ultrawork + git-master + ralph-loop)

**워크플로우**:

```
[Phase 0: 사전 분석 - Metis]

1. 숨겨진 요구사항 도출
   - CI/CD 파이프라인도 변경 필요
   - 기존 브랜치 전략과의 호환성
   - 팀원들의 로컬 환경 마이그레이션 가이드 필요
   - IDE 설정 파일 (.vscode, .idea) 업데이트

2. 기술적 위험 식별
   - 위험 1: 패키지 의존성 충돌 (모노레포 도구 호환성)
   - 위험 2: 빌드 캐시 무효화로 인한 빌드 시간 증가
   - 위험 3: import 경로 전체 변경으로 인한 런타임 에러
   - 위험 4: 테스트 환경 설정 깨짐

3. 롤백 전략
   - Phase별 독립 롤백 가능하도록 설계
   - 최악의 경우: git revert로 전체 롤백 가능해야 함
```

```
[Phase 1: 계획 - Prometheus]

1. 마이그레이션 전략 수립
   - Big Bang vs 점진적 → 점진적 선택 (위험 분산)
   - 도구 선택: Turborepo / Nx / pnpm workspace
   - 디렉토리 구조 설계

2. 단계별 계획

   Step 1: 모노레포 셸 구축 (기존 코드 무변경)
     - root package.json, turbo.json 생성
     - 기존 프로젝트를 서브디렉토리로 이동
     - 모든 기존 기능이 동작하는지 확인

   Step 2: 공유 패키지 추출
     - 공통 타입, 유틸리티를 shared 패키지로 추출
     - 기존 프로젝트에서 shared import로 변경

   Step 3: 빌드 파이프라인 통합
     - turbo로 빌드 오케스트레이션
     - 캐시 설정 최적화

   Step 4: CI/CD 마이그레이션
     - GitHub Actions 워크플로우 업데이트
     - 변경된 패키지만 빌드/배포하도록 최적화

   Step 5: 개발 환경 정비
     - 팀원 가이드 문서 작성
     - IDE 설정 업데이트
     - 개발 스크립트 통합
```

```
[Phase 2: 리뷰 - Momus + Metis]

1. 아키텍처 리뷰 (Momus)
   - 디렉토리 구조가 확장 가능한가
   - 의존성 방향이 올바른가 (shared → app, 역방향 금지)
   - 빌드 캐시 전략이 효과적인가

2. 위험 재평가 (Metis)
   - Phase 0에서 식별한 위험이 계획에서 해소되었는가
   - 새로 발견된 위험은 없는가
   - 롤백 전략이 각 단계에서 작동하는가
```

```
[Phase 3: 단계별 구현 - Sisyphus + Ultrawork + Ralph-Loop]

Step 1 실행 → 검증 → 커밋
  - 모든 기존 테스트 통과 확인
  - 개발 서버 정상 기동 확인
  - 빌드 성공 확인
  ✓ 검증 완료 → Step 2 진행

Step 2 실행 → 검증 → 커밋
  - 공유 패키지 import 정상 확인
  - 타입 체크 통과 확인
  - 전체 테스트 통과 확인
  ✓ 검증 완료 → Step 3 진행

  ... (각 Step마다 동일한 검증 사이클)

Ralph-Loop: 모든 Step이 완료될 때까지 중단하지 않음
```

```
[Phase 4: 통합 검증]

1. 전체 빌드: pnpm run build (모든 패키지)
2. 전체 테스트: pnpm run test (모든 패키지)
3. E2E 테스트: Playwright 전체 스위트
4. 성능 검증: 빌드 시간 before/after 비교
5. 개발 경험 검증: dev 서버 기동, HMR 동작 확인
6. CI/CD 검증: 테스트 브랜치에서 파이프라인 실행
```

**소요 시간**: 3~5일

**핵심 포인트**: XL 작업에서 가장 중요한 것은 **각 단계가 독립적으로 검증 가능하고 롤백 가능**하다는 것이다. "한 방에 끝내기"는 XL 작업에서 가장 위험한 접근이다. **점진적 마이그레이션 + 단계별 검증**이 유일한 안전한 방법이다.

---

## 검증 매트릭스 요약

| 크기 | Quality Gate | 단위 테스트 | 통합 테스트 | E2E 테스트 | 수동 테스트 | 코드 리뷰 |
|------|:-----------:|:---------:|:---------:|:--------:|:---------:|:--------:|
| **S** | 자동 | - | - | - | - | - |
| **M** | 자동 | 권장 | - | - | 권장 | - |
| **L** | 자동 | 필수 | 권장 | 선택 | 필수 | 필수 |
| **XL** | 자동 | 필수 | 필수 | 필수 | 필수 | 필수 |

---

## 의사결정 치트시트

빠르게 판단해야 할 때 참조하는 축약 가이드:

```
파일 1개 + 5줄 이하     → S → 바로 수행
파일 2~5개 + 분석 필요  → M → sisyphus + (debugging)
파일 5~15개 + 설계 필요 → L → prometheus → momus → sisyphus + ultrawork
파일 15개+ + 시스템 변경 → XL → metis → prometheus → momus → sisyphus + ralph-loop
```

```
병렬 가능?      → + ultrawork
3+ 파일 변경?   → + git-master
프론트엔드?     → + frontend-ui-ux
버그?           → + systematic-debugging
반드시 완료?    → + ralph-loop
```

---

## 컨텍스트 관리 전략

작업의 생산성은 **컨텍스트 윈도우를 얼마나 효과적으로 관리하느냐**에 달려 있다. 200k 토큰의 컨텍스트 윈도우는 무한하지 않으며, 오래된 컨텍스트는 성능을 저하시킨다.

> "컨텍스트는 우유와 같다. 신선하고 압축된 상태를 유지해야 한다." — ykdojo

### 단일 목적 대화 원칙

하나의 대화 세션에서 하나의 작업만 수행한다. 여러 작업을 섞으면 컨텍스트가 오염되어 AI의 성능이 저하된다.

```
❌ 잘못된 예: 하나의 세션에서 버그 수정 + 새 기능 추가 + 리팩토링
✅ 올바른 예: 세션 1(버그 수정) → 세션 2(새 기능) → 세션 3(리팩토링)
```

작업 전환이 필요하면 `/clear`로 대화를 정리하거나, 새 세션을 시작한다.

### HANDOFF.md 패턴

장시간 작업이나 컨텍스트가 커진 경우, **HANDOFF.md 파일로 컨텍스트를 압축**하여 새 세션에 전달한다.

```
[세션 1: 작업 진행]
  컨텍스트가 70% 이상 사용됨
  → HANDOFF.md 생성 (현재 상태, 완료된 작업, 남은 작업, 주요 결정 사항)

[세션 2: 이어서 작업]
  "HANDOFF.md를 읽고 이어서 작업해줘"
  → 압축된 컨텍스트로 신선하게 시작
```

HANDOFF.md에 포함할 내용:
1. **현재 상태**: 어떤 작업을 진행 중인지
2. **완료된 항목**: 이미 끝난 작업 목록
3. **남은 항목**: 아직 해야 할 작업
4. **핵심 결정 사항**: 내려진 아키텍처/설계 결정
5. **주의 사항**: 다음 세션에서 알아야 할 트러블슈팅 정보

### 컨텍스트 모니터링

```bash
/context   # 컨텍스트 윈도우 사용 현황 확인
/usage     # 토큰 사용량 및 한도 확인
/clear     # 대화 내용 지우고 새로 시작
```

- **컨텍스트 60% 이상**: 불필요한 대화 정리 고려
- **컨텍스트 80% 이상**: HANDOFF.md 작성 후 새 세션 시작 권장
- **대화 이름 지정**: `/rename auth-refactor` 처럼 세션에 의미 있는 이름을 붙여 나중에 찾기 쉽게 관리

---

## 출력 검증 방법

AI가 생성한 코드를 맹목적으로 신뢰하지 않는다. 4가지 검증 방법을 상황에 맞게 조합한다.

### 방법 1: 자동 검증 (Quality Gate)

Stop Hook이 매 작업 후 자동으로 lint/typecheck를 실행한다. 가장 기본적이고 빠른 검증이다.

### 방법 2: 테스트 코드

```
> "이 함수에 대한 테스트를 작성해줘. 엣지 케이스도 포함해야 해."
```

TDD를 적용하면 코드 작성과 동시에 검증이 이루어진다. Superpowers의 TDD 스킬을 활용한다.

### 방법 3: Draft PR 생성

```
> "draft PR을 만들어줘"
```

PR 화면에서 diff를 시각적으로 검토한다. 코드 변경의 전체 맥락을 파악하기에 가장 효과적이다.

### 방법 4: 자기 검증 요청

```
> "방금 생성한 코드를 다시 검토해줘.
  모든 주장을 검증하고, 검증 결과를 표로 정리해줘."
```

Claude가 자신의 출력을 재검토하게 한다. momus(리뷰 에이전트)를 활용하면 더 엄격한 검증이 가능하다.

### 검증 방법 선택 가이드

| 작업 크기 | 권장 검증 조합 |
|----------|-------------|
| S | 방법 1 (Quality Gate만) |
| M | 방법 1 + 방법 2 (테스트) |
| L | 방법 1 + 방법 2 + 방법 3 (PR) |
| XL | 방법 1 + 방법 2 + 방법 3 + 방법 4 (자기 검증) |

---

이 방법론의 핵심은 **판단의 효율성**이다. 작업 크기를 빠르게 판단하고, 적절한 Skill 조합을 적용하여, 과잉/과소 프로세스를 모두 피하는 것. 이것이 **Right-Sized Process**의 실천이다.

---

## 검증 훅 패턴 (Domain Verify)

출력 검증을 한 단계 발전시킨 **자동 도메인 검증** 시스템. AI가 특정 도메인의 파일을 편집할 때, PostToolUse 훅이 해당 도메인의 검증 체크리스트를 Claude 컨텍스트에 직접 주입한다.

### 기존 검증과의 차이

| 방식 | 시점 | 대상 | 한계 |
|------|------|------|------|
| Quality Gate (Stop Hook) | 작업 완료 후 | lint, typecheck, test | 도메인 규칙은 검증 불가 |
| Domain Verify (PostToolUse Hook) | **파일 편집 직후** | 도메인별 코딩 규칙 | 패턴 매칭 범위에 의존 |

### 작동 원리

```
Claude가 파일 편집 (Edit/Write)
    ↓
PostToolUse 훅 실행 → case 패턴 매칭
    ↓  매칭됨                  ↓  안 됨
체크리스트 직접 주입           exit 0 (무시)
    ↓
Claude가 즉시 자가 검증 → 위반 시 자동 수정
```

### 핵심 설계 결정

1. **체크리스트 직접 임베딩** — 스킬 호출에 의존하면 Claude가 무시할 수 있다. 훅이 JSON message로 직접 주입하면 100% 결정적.
2. **단일 스크립트** — 백엔드/프론트엔드/DB 모든 패턴을 하나의 shell script에서 처리. jq 파싱 1회.
3. **v2 경로 한정** — v1 레거시 파일에 v2 규칙이 적용되는 오탐 방지.
4. **Kill switch** — `SKIP_DOMAIN_VERIFY=1` 환경변수로 비활성화 가능.

### 적용 예시

```bash
# case 블록 예시 (hooks/domain-verify.sh)
case "$FILE_PATH" in
  */api/v2/*/*repository*.py)
    MSG="[Domain Verify: SQL 안전성] — CRITICAL 검증:
    금지: f-string 값 삽입, replace sanitize, f-string IN절
    필수: %s 바인딩, = ANY(%s), params: tuple = ()
    위반 발견 시 즉시 수정하세요." ;;
esac
```

### 플러그인

`plugins/domain-verify/` 에 범용 템플릿으로 제공. 새 프로젝트에 복사하여 도메인별 규칙만 커스터마이징하면 즉시 사용 가능. 상세는 [플러그인 README](../plugins/domain-verify/README.md) 참조.
